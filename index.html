<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>MultiSig Wallet Transaction Tracker</title>
    <script src="https://cdn.jsdelivr.net/npm/ethers@6.7.0/dist/ethers.umd.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Roboto:wght@300;400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-primary: #0a192f;
            --bg-secondary: #112240;
            --text-primary: #e6f1ff;
            --text-secondary: #8892b0;
            --accent-color: #64ffda;
        }

        body {
            font-family: 'Roboto', sans-serif;
            background: linear-gradient(135deg, var(--bg-primary), var(--bg-secondary));
            background-image: url('pexels-maxfrancis-2246476.jpg');
            background-size: cover;
            background-position: center;
            background-attachment: fixed;
            color: var(--text-primary);
            margin: 0;
            padding: 20px;
            min-height: 100vh;
            background-attachment: fixed;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
            background: rgba(17, 34, 64, 0.8);
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }

        h1 {
            font-family: 'Orbitron', sans-serif;
            text-align: center;
            color: var(--accent-color);
            margin-bottom: 30px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .tx-form {
            display: grid;
            gap: 15px;
            margin-bottom: 30px;
        }

        input, button {
            padding: 10px;
            border-radius: 5px;
            border: 1px solid var(--text-secondary);
            background: var(--bg-primary);
            color: var(--text-primary);
            font-family: 'Roboto', sans-serif;
        }

        button {
            background-color: var(--accent-color);
            color: var(--bg-primary);
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
        }

        button:hover {
            opacity: 0.8;
        }

        button:disabled {
            background-color: var(--text-secondary);
            cursor: not-allowed;
        }

        .transaction-container {
            display: grid;
            gap: 15px;
        }

        .transaction-card {
            background: rgba(25, 50, 80, 0.7);
            border-radius: 10px;
            padding: 15px;
            border-left: 5px solid;
        }

        .transaction-pending {
            border-left-color: #ffd700;
        }

        .transaction-executed {
            border-left-color: #00ff7f;
        }

        .transaction-card div {
            margin-bottom: 5px;
            font-size: 0.9em;
            color: var(--text-secondary);
        }

        #connectButton {
            width: 100%;
            margin-bottom: 20px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>MultiSig Wallet Tracker</h1>
        <button id="connectButton">Connect Wallet</button>

        <div class="tx-form">
            <h2>Submit Transaction</h2>
            <input type="text" id="toInput" placeholder="Recipient Address" required>
            <input type="number" step="0.00001" id="valueInput" placeholder="Value (ETH)" required>
            <input type="number" id="nonceInput" placeholder="Nonce" required>
            <input type="text" id="dataInput" placeholder="Data (optional, hex)">
            <button id="submitTxButton">Submit Transaction</button>
        </div>

        <div id="transactionContainer" class="transaction-container"></div>
    </div>

    <script>
        // Contract details
        const CONTRACT_ADDRESS = '0x655af9aab14a277ef7812797bd1794da34d397bc';
        const CONTRACT_ABI = [
            "function executeTransaction(uint256 nonce, address to, uint256 value, bytes calldata data) external",
            "event TransactionApproved(bytes32 indexed txHash, address indexed approver, uint8 currentApprovals)",
            "event TransactionEvent(bytes32 indexed txId, address indexed to, uint nonce, bytes data)"
        ];

        // Global variables
        let signer = null;
        let contract = null;
        let transactions = {};

        // Elements
        const connectButton = document.getElementById('connectButton');
        const transactionContainer = document.getElementById('transactionContainer');
        const nonceInput = document.getElementById('nonceInput');
        const toInput = document.getElementById('toInput');
        const valueInput = document.getElementById('valueInput');
        const dataInput = document.getElementById('dataInput');
        const submitTxButton = document.getElementById('submitTxButton');

        // Retrieve past transactions from blockchain
        async function retrievePastTransactions(contract) {
            try {
                // Retrieve past TransactionApproved events
                const approvedEvents = await contract.queryFilter('TransactionApproved');
                
                // Retrieve past TransactionEvent events
                const executedEvents = await contract.queryFilter('TransactionEvent');

                // Create a map to track transaction states
                const pastTransactions = {};

                // Process approval events first
                approvedEvents.forEach(event => {
                    const { txHash, approver, currentApprovals } = event.args;
                    const txHashStr = txHash.toString();

                    pastTransactions[txHashStr] = {
                        approvals: Number(currentApprovals),
                        approvers: [approver],
                        status: 'Pending'
                    };
                });

                // Update with execution events
                executedEvents.forEach(event => {
                    const { txId, to, nonce, data } = event.args;
                    const txIdStr = txId.toString();

                    if (pastTransactions[txIdStr]) {
                        pastTransactions[txIdStr].status = 'Executed';
                        pastTransactions[txIdStr].to = to;
                        pastTransactions[txIdStr].nonce = Number(nonce);
                        pastTransactions[txIdStr].data = data;
                    }
                });

                return pastTransactions;
            } catch (error) {
                console.error('Error retrieving past transactions', error);
                return {};
            }
        }

        // Connect wallet and setup contract
        async function connectWallet() {
            if (!window.ethereum) {
                alert('MetaMask not found!');
                return;
            }

            try {
                // Request account access
                await window.ethereum.request({ method: 'eth_requestAccounts' });
                
                // Create provider and signer
                const provider = new ethers.BrowserProvider(window.ethereum);
                signer = await provider.getSigner();

                // Create contract instance
                contract = new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, signer);

                // Retrieve past transactions when connecting
                transactions = await retrievePastTransactions(contract);
                renderTransactions();

                // Listen for new TransactionApproved events
                contract.on('TransactionApproved', (txHash, approver, currentApprovals) => {
                    const txHashStr = txHash.toString();
                    
                    // Update or create transaction entry
                    transactions[txHashStr] = {
                        approvals: Number(currentApprovals),
                        approvers: [...new Set([
                            ...(transactions[txHashStr]?.approvers || []), 
                            approver
                        ])],
                        status: 'Pending'
                    };

                    renderTransactions();
                });

                // Listen for new TransactionEvent (completed transactions)
                contract.on('TransactionEvent', (txId, to, nonce, data) => {
                    const txIdStr = txId.toString();
                    
                    // Update transaction to executed
                    if (transactions[txIdStr]) {
                        transactions[txIdStr].status = 'Executed';
                        transactions[txIdStr].to = to.toString();
                        transactions[txIdStr].nonce = Number(nonce);
                        transactions[txIdStr].data = data.toString();
                    }

                    renderTransactions();
                });

                connectButton.textContent = 'Connected';
                connectButton.disabled = true;
                submitTxButton.disabled = false;

            } catch (error) {
                console.error('Connection failed', error);
                alert('Failed to connect wallet');
            }
        }

        // Submit transaction with ETH conversion
        async function submitTransaction() {
            if (!contract) {
                alert('Please connect wallet first');
                return;
            }

            try {
                const nonce = BigInt(nonceInput.value);
                const to = toInput.value;
                
                // Convert ETH to wei
                const valueInEth = parseFloat(valueInput.value);
                const value = BigInt(ethers.parseEther(valueInEth.toString()));
                
                const data = dataInput.value || '0x';

                const tx = await contract.executeTransaction(nonce, to, value, data);
                await tx.wait();

                // Clear inputs
                nonceInput.value = '';
                toInput.value = '';
                valueInput.value = '';
                dataInput.value = '';

                alert('Transaction submitted successfully!');
            } catch (error) {
                console.error('Transaction submission failed', error);
                alert(`Transaction failed: ${error.message}`);
            }
        }

        // Render transactions to the DOM
        function renderTransactions() {
            transactionContainer.innerHTML = Object.entries(transactions).map(([txHash, txDetails]) => `
                <div class="transaction-card ${txDetails.status === 'Executed' ? 'transaction-executed' : 'transaction-pending'}">
                    <div><strong>Transaction Hash:</strong> ${txHash.substring(0,10)}...</div>
                    <div><strong>Approvals:</strong> ${txDetails.approvals || 0}/2 
                        ${txDetails.status === 'Executed' ? 'âœ…' : ''}</div>
                    <div><strong>Approvers:</strong> ${(txDetails.approvers || []).join(', ')}</div>
                    <div><strong>Status:</strong> ${txDetails.status || 'Pending'}</div>
                    ${txDetails.to ? `<div><strong>To:</strong> ${txDetails.to}</div>` : ''}
                    ${txDetails.nonce !== undefined ? `<div><strong>Nonce:</strong> ${txDetails.nonce}</div>` : ''}
                </div>
            `).join('');
        }

        // Event listeners
        connectButton.addEventListener('click', connectWallet);
        submitTxButton.addEventListener('click', submitTransaction);
        
        // Initially disable submit button
        submitTxButton.disabled = true;
    </script>
</body>
</html>
